<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_CSVReader" Id="{18a647bb-1855-4bb8-b447-e137dbddf186}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  FB_CSVReader: CSV 파일 읽기와 파싱을 하나의 Function Block에서 처리합니다.
  - 파일 크기(fileSize) 조회
  - 평균 행 길이(avgLineLength) 기준 동적 최대 행 개수 계산
  - sep 구분자에 따라 각 행을 필드별로 분리하여 arrLines에 저장
  - 완료 플래그(bDone), 에러 플래그(bError)
  사용 예:
    fbCsv(
      sPathName     := 'C:\Temp\data.csv',
      avgLineLength := 100,
      sep           := ','
    );
    IF fbCsv.bDone THEN
      (* fbCsv.fileSize, fbCsv.idxLine, fbCsv.arrLines 사용 *)
    END_IF
*)
FUNCTION_BLOCK FB_CSVReader
VAR_INPUT
    sPathName     : STRING(255);   (* CSV 파일 경로 *)
    avgLineLength : DINT := 80;    (* 평균 한 줄 길이(바이트) *)
    sep           : STRING(1) := ','; (* 필드 구분자 *)
END_VAR
VAR_OUTPUT
    fileSize      : DINT;    (* 파일 크기(바이트) *)
    idxLine       : INT;     (* 실제 읽은 줄 수 *)
    bDone         : BOOL;    (* 완료 플래그 *)
    bError        : BOOL;    (* 에러 플래그 *)
    arrLines      : ARRAY[0..cMaxLines-1] OF ARRAY[0..cMaxFields-1] OF T_MaxString; (* 파싱된 CSV 데이터 *)
END_VAR

VAR
    dynamicMax   : INT;        (* 동적 최대 행 수 *)
    hFile        : UINT;       (* 파일 핸들 *)
    sLine        : T_MaxString;(* 한 줄 버퍼 *)
    idxField     : INT;        (* 현재 필드 인덱스 *)
    eState       : INT;        (* 0:Open→1:SeekEnd→2:Tell→3:CalcMax→4:SeekStart→5:Read→6:Close→7:Done *)
    fbOpen       : FB_FileOpen;
    fbSeek       : FB_FileSeek;
    fbTell       : FB_FileTell;
    fbGets       : FB_FileGets;
    fbCsvReader  : FB_CSVMemBufferReader;
    fbClose      : FB_FileClose;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE eState OF

  0: (* 파일 열기 (바이너리 모드) *)
    fbOpen(
      sPathName := sPathName,
      nMode     := FOPEN_MODEREAD OR FOPEN_MODEBINARY,
      bExecute  := TRUE
    );
    IF NOT fbOpen.bBusy THEN
      IF fbOpen.bError THEN
        bError := TRUE;
        eState := 7;
      ELSE
        hFile := fbOpen.hFile;
        eState := 1;
      END_IF
    END_IF

  1: (* 파일 끝으로 포인터 이동 *)
    fbSeek(
      hFile    := hFile,
      eOrigin  := SEEK_END,
      nSeekPos := 0,
      bExecute := TRUE
    );
    IF NOT fbSeek.bBusy THEN
      IF fbSeek.bError THEN
        bError := TRUE;
        eState := 7;
      ELSE
        eState := 2;
      END_IF
    END_IF

  2: (* 파일 크기 조회 *)
    fbTell(
      hFile    := hFile,
      bExecute := TRUE
    );
    IF NOT fbTell.bBusy THEN
      IF fbTell.bError THEN
        bError := TRUE;
        eState := 7;
      ELSE
        fileSize := fbTell.nSeekPos;
        eState := 3;
      END_IF
    END_IF

  3: (* 동적 최대 행 계산 & 파일 시작점 복귀 *)
    IF avgLineLength > 0 THEN
      dynamicMax := DINT_TO_INT(fileSize / avgLineLength);  (* DINT 간 나눗셈 결과 INT로 자동 변환 *)
    ELSE
      dynamicMax := cMaxLines;
    END_IF
    IF dynamicMax > cMaxLines THEN
      dynamicMax := cMaxLines;
    END_IF
    fbSeek(
      hFile    := hFile,
      eOrigin  := SEEK_SET,
      nSeekPos := 0,
      bExecute := TRUE
    );
    eState := 4;

  4: (* 필드 구분자 설정 및 첫 줄 읽기 준비 *)
    DEFAULT_CSV_FIELD_SEP := STRING_TO_BYTE(sep);  (* 구분자 글로벌 설정 *)
    idxLine := 0;
    bDone := FALSE;
    fbGets(
      hFile    := hFile,
      bExecute := TRUE
    );
    eState := 5;

  5: (* 다중 행 읽기 및 파싱 *)
    IF NOT fbGets.bBusy THEN
      IF fbGets.bError OR fbGets.bEOF THEN
        fbClose(
          hFile    := hFile,
          bExecute := TRUE
        );
        eState := 6;
      ELSE
        IF idxLine < dynamicMax THEN
          sLine := fbGets.sLine;
          fbCsvReader(
            eCmd     := eEnumCmd_First,
            pBuffer  := ADR(sLine),
            cbBuffer := LEN(sLine)
          );
          idxField := 0;
          WHILE fbCsvReader.bOk AND (idxField < cMaxFields) DO
            arrLines[idxLine][idxField] := fbCsvReader.getValue;
            idxField := idxField + 1;
            fbCsvReader(
              eCmd     := eEnumCmd_Next,
              pBuffer  := ADR(sLine),
              cbBuffer := LEN(sLine)
            );
          END_WHILE
          idxLine := idxLine + 1;
        END_IF
        fbGets(
          hFile    := hFile,
          bExecute := TRUE
        );
      END_IF
    END_IF

  6: (* 파일 닫기 *)
    IF NOT fbClose.bBusy THEN
      IF fbClose.bError THEN
        bError := TRUE;
      ELSE
        bDone := TRUE;
      END_IF
      eState := 7;
    END_IF

  7: (* 완료 상태 유지 *)
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>